grammar org.agileware.natural.cucumber.Cucumber hidden(WS, SL_COMMENT)

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
generate cucumber "http://www.agileware.org/natural/cucumber"


// ----------------------------------------------------------
//
// AST Elements
//
// ----------------------------------------------------------

// --------------------------------------
// Feature
// --------------------------------------

Feature: {Feature}
	meta=Meta?
	'Feature:'
	title=Text? EOL+
	narrative=Narrative?
	background=Background?
	scenarios+=AbstractScenario*
;

Narrative:
	lines+=TextLine+
;


// --------------------------------------
// Background
// --------------------------------------

Background: {Background}
	'Background:'
	title=Text? EOL+
	narrative=Narrative?
	steps+=Step*
;

// --------------------------------------
// AbstractScenario
// --------------------------------------
	
AbstractScenario: (Scenario | ScenarioOutline);

Scenario: {Scenario}
	meta=Meta?
	'Scenario:'
	title=Text? EOL+
	narrative=Narrative?
	steps+=Step*
;

ScenarioOutline:
	meta=Meta?
	'Scenario' 'Outline:'
	title=Text? EOL+
	narrative=Narrative?
	steps+=Step*
	examples+=Example
	(EOL+ examples+=Example)*
;

// --------------------------------------
// Example
// --------------------------------------

Example:
	meta=Meta?
	'Examples:'
	title=Text? EOL+
	narrative=Narrative?
	table=Table
;

// --------------------------------------
// Step
// --------------------------------------

Step:
	keyword=STEP_KEYWORD
	description=Text EOL+
	(table=Table | text=DocString)?
;

STEP_KEYWORD: ANY_KEYWORD
	| GIVEN_KEYWORD
	| WHEN_KEYWORD
	| THEN_KEYWORD
	| AND_KEYWORD
	| BUT_KEYWORD
;

terminal ANY_KEYWORD: '*';
terminal GIVEN_KEYWORD: 'Given';
terminal WHEN_KEYWORD: 'When';
terminal THEN_KEYWORD: 'Then';
terminal AND_KEYWORD: 'And';
terminal BUT_KEYWORD: 'But';

// --------------------------------------
// Meta
// --------------------------------------

Meta:
	tags+=Tag
	(EOL? tags+=Tag)*
	EOL+
;

Tag:
	'@' key=WORD
	(':'? value=Text)?
;

// --------------------------------------
// Table
// --------------------------------------

Table:
	rows+=TableRow+
;

TableRow: {TableRow}
	cols+=TableCol+ '|' EOL
;

TableCol: {TableCol}
	TABLE_CELL
;

terminal TABLE_CELL: '|' !('|' | '\n' | '\r')*;

// --------------------------------------
// DocString
// --------------------------------------
	
DocString: {DocString}
	(('"""' EOL lines+=TextLine* '"""')
		| ("'''" EOL lines+=TextLine* "'''"))
	EOL+
;


// ----------------------------------------------------------
//
// Common Elements
//
// ----------------------------------------------------------

TextLine: {TextLine}
 	value=Text EOL+
;

Text returns ecore::EString:
 	TextLiteral+
;

TextLiteral: PLACEHOLDER
	| WORD
	| PUNCTUATION
;
	
terminal PLACEHOLDER:
	('<' WORD '>')
	| ('[' WORD ']')
;

terminal WORD: 
	(LETTER | DIGIT)
	(LETTER | DIGIT | '_' | '-' | '.' )*
;

terminal SL_COMMENT: '#' !('\n' | '\r')* NL;

// TODO - it is not clear what the rammifications of creating a terminal from all
//        valid punction symbols, when the ANY_OTHER terminal should suffice for the
//        end result a lot more efficiently (EG. potentially unbounded n where n is
//        terminal count in grammar)
terminal PUNCTUATION: CHAR;

terminal EOL: NL;

terminal WS: (SPACE | '\t');

terminal fragment NL: ('\r'? '\n');


// ----------------------------------------------------------
//
// Unicode Character Ranges
//
// ----------------------------------------------------------

terminal fragment CHAR: ASCII_CHAR;

terminal fragment SPACE: ASCII_SPACE;

terminal fragment DIGIT: ASCII_DIGIT;

terminal fragment LETTER: LATIN_ALPHABET;

// Basic Latin
////

terminal fragment ASCII_SPACE: '\u0020';

terminal fragment ASCII_DIGIT: ('\u0030'..'\u0039');

// all ascii chars other than letters, digits, or space
terminal fragment ASCII_CHAR: ('\u0021'..'\u002F')
	| ('\u003A'..'\u0040')
	| ('\u005B'..'\u0060')
	| ('\u007B'..'\u007E')
;

terminal fragment LATIN_ALPHABET: ('\u0041'..'\u005A')
	| ('\u0061'..'\u007A')
;
