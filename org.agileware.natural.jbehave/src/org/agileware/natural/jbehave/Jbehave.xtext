grammar org.agileware.natural.jbehave.Jbehave hidden(WS, SL_COMMENT)

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
generate jbehave "http://www.agileware.org/natural/jbehave"

// Story
////

// The story describes a feature via description, narrative and a set of scenarios
// Story := Description? Meta? Narrative? GivenStories? Lifecycle? Scenario+ ;
Story:
	(description=Description EOL+)?
	(meta=Meta EOL+)?
	(narrative=Narrative EOL+)?
	(lifecycle=Lifecycle EOL+)?
	scenarios+=Scenario*
;

// The Description is expressed by any sequence of words that must not contain any keywords at start of lines.
// Description := (Word Space?)* ;
Description:
	lines+=DescriptionLine
	(EOL lines+=DescriptionLine)*
;

DescriptionLine: WORD+;

// The meta is identified by keyword "Meta:" (or equivalent in I18n-ed locale),
// It is followed by any number of meta elements
// Meta:= "Meta:" (MetaElement)* ;
Meta: {Meta}
	'Meta:'
	elements+=MetaElement
	(EOL elements+=MetaElement)*
;

// The meta element is identified by keyword "@" (or equivalent in I18n-ed locale),
// It is followed by a name-value pair, where the value can be empty or have multiple words
// MetaElement:= "@" Space? Word Space (Word Space?)* ;
MetaElement:
	'@'
	key=WORD
	(':'? value=MetaElementValue)?
;

MetaElementValue: WORD+;


// Narrative
////

// The narrative is identified by keyword "Narrative:" (or equivalent in I18n-ed locale),
// It is followed by the narrative elements
// Narrative:= "Narrative:" ( InOrderTo AsA IWantTo | AsA IWantTo SoThat ) ;
Narrative:
	NarrativeA | NarrativeB
;

NarrativeA: {NarrativeA}
	'Narrative:'
	inOrderTo=InOrderTo asA=AsA wantTo=IWantTo
;

NarrativeB: {NarrativeB}
	'Narrative:'
	asA=AsA wantTo=IWantTo soThat=SoThat
;

// InOrderTo:= "In order to" NarrativeElementContent ;
InOrderTo:
	EOL
	IN_ORDER_TO
	content=NarrativeElementContent
;

// AsA:= "As a" NarrativeElementContent ;
AsA:
	EOL
	AS_A
	content=NarrativeElementContent
;

// IWantTo:= "I want to" NarrativeElementContent ;
IWantTo:
	EOL
	I_WANT_TO
	content=NarrativeElementContent
;

// SoThat:= "So that" NarrativeElementContent ; 
SoThat:
	EOL
	SO_THAT
	content=NarrativeElementContent
;

// The narrative element content is any sequence of characters that do not match a narrative starting word
// NarrativeElementContent := ? Any sequence of NarrativeCharacter that does not match NarrativeStartingWord ? ;
NarrativeElementContent: WORD+;

terminal IN_ORDER_TO: 'In order to';

terminal AS_A: 'As a';

terminal I_WANT_TO: 'I want to';

terminal SO_THAT: 'So that';


// Scenario
////

// The scenario is identified by keyword "Scenario:" (or equivalent in I18n-ed locale),
// which is optional in the case of a single scenario.
// It can optionally be followed by a title, which is expressed by any sequence of words
// that must not contain any keywords at start of lines.
// It is followed by one or more Steps.
// Scenarios can optionally contain comments (which are not part of the scenarios) after examples using "!--" keyword
// Scenario := "Scenario:"? Title? Meta? GivenStories? Step+ Examples? (Examples Comment+)? ;
Scenario: {Scenario}
	'Scenario:' (title=Title)? EOL+
	(meta=Meta EOL+)?
	(given=GivenStories EOL+)?
	steps+=Step
	(EOL steps+=Step)*
	(EOL+ examples=Examples)?
;

// The free-text description
// Title := (Word Space?)* ;
Title: WORD+;

// The comma-separated list of story resources that specify the stories to be run before a story or a scenario
// GivenStories:= "GivenStories:" (StoryPath ','?)+ ;
GivenStories: {GivenStories}
	'GivenStories:' resources+=FilePath
	(',' EOL? resources+=FilePath)*
;


// Lifecycle
////

// The lifecycle is identified by keyword "Lifecycle:" (or equivalent in I18n-ed locale),
// It is followed by the lifecycle elements
// Lifecycle:= "Lifecycle:" LifecycleBefore? LifecycleAfter?
Lifecycle: {Lifecycle}
	'Lifecycle:'
	(EOL+ before=LifecycleBefore)?
	(EOL+ after=LifecycleAfter)?
;


// The before lifecyle element identified by keyword "Before:" (or equivalent in I18n-ed locale),
// followed by one or more steps
// LifecycleBefore:= "Before:" (Scope? Step+)+
LifecycleBefore:
	"Before:"
	(EOL elements+=LifecycleBeforeElement)+
;

LifecycleBeforeElement:
	scope=Scope
	(EOL steps+=Step)+
;

// The after lifecyle element identified by keyword "After:" (or equivalent in I18n-ed locale),
// followed by one or more sets of scope, outcome, meta filter and steps
// LifecycleAfter:= "After:" (Scope? Outcome? MetaFilter? Step+)+
LifecycleAfter:
	"After:"
	(EOL elements+=LifecycleAfterElement)+
;

LifecycleAfterElement:
	scope=Scope
	(EOL outcome=Outcome)?
	(EOL steps+=Step)+
	(EOL+ filter=MetaFilter)?
;

// The scope element identified by keyword "Scope:" (or equivalent in I18n-ed locale),
// Scope:= "Scope:" "STEP" | "SCENARIO" | "STORY"
Scope:
	"Scope:"
	type=ScopeType
;

enum ScopeType: STEP
	| SCENARIO
	| STORY
;

// The outcome element identified by keyword "Outcome:" (or equivalent in I18n-ed locale),
// Outcome:= "Outcome:" "ANY" | "SUCCESS" | "FAILURE" ;
Outcome:
	"Outcome:"
	type=OutcomeType
;

enum OutcomeType: ANY
	| SUCCESS
	| FAILURE
;

// The meta filter element identified by keyword "MetaFilter:" (or equivalent in I18n-ed locale),
// MetaFilter:= "MetaFilter:" (Word Space?)*
MetaFilter: {MetaFilter}
	"MetaFilter:"
	elements+=MetaElement+
;


// Step
////

// The scenario step is a step starting work followed by any number of characters
// Step := StepStartingWord StepContent ;
Step:
	type=StepStartingWord
	content=StepContent
;

StepContent:
	(WORD | NUMBER | EXAMPLE_WORD)+
;

// The step starting words (or equivalent in I18n-ed locale)
// StepStartingWord := ("Given" | "When" | "Then" | "And" | "!--" ) ;
enum StepStartingWord:
	GIVEN="Given"
	| WHEN="When"
	| THEN="Then"
	| AND="And";

// TODO: support multiple wrapping symbols / quotations
terminal EXAMPLE_WORD:
	('<' WORD '>')
	| ('[' WORD ']')
;


// Examples
////

// The examples table
// Examples := "Examples:" ExamplesTable ;
Examples:
	'Examples:'
	table=Table;

// The examples table comprises of a header row and data rows
// ExamplesTable := ExamplesTableHeader ExamplesTableRow+ ;
Table:
	header=TABLE_ROW
	rows+=TABLE_ROW+
;

// The examples table header contains the column names, separated by ExamplesTableColumnSeparator
// ExamplesTableHeader := (ExamplesTableColumnSeparator ExamplesTableCharacter+)+ ExamplesTableColumnSeparator  Newline ;

// The examples table row contains the column values, separated by ExamplesTableColumnSeparator
// ExamplesTableRow := (ExamplesTableColumnSeparator ExamplesTableCharacter+)+ ExamplesTableColumnSeparator  Newline ;

// The examples table character can be any character, expect for ExamplesTableColumnSeparator and Newline
// ExamplesTableCharacter := ? Any Unicode character except ExamplesTableColumnSeparator and Newline ? ;
terminal TABLE_ROW: 
	'|' (!('|' | '\n' | '\r')* '|')+ (' ' | '\t')* NL
;


// Common Elements
////

FilePath returns ecore::EString:
	(WORD | './' | '../' | '/') WORD ('/' WORD)*
;

terminal WORD: 
	(LETTER | DIGIT) (LETTER | DIGIT | '_' | '-' | '.')*
;

terminal NUMBER returns ecore::EDouble:
	'-'? (DIGIT)+ ('.' (DIGIT)+)?
;

//terminal STRING:
//	'"' ('\\' ('b' | 't' | 'n' | 'f' | 'r' | 'u' | '"' | "'" | '\\') | !('\\' | '"'))* '"' |
//	"'" ('\\' ('b' | 't' | 'n' | 'f' | 'r' | 'u' | '"' | "'" | '\\') | !('\\' | "'"))* "'"
//;

terminal SL_COMMENT: '#' !('\n' | '\r')* NL;

terminal fragment LETTER: ('a'..'z' | 'A'..'Z');

terminal fragment DIGIT: ('0'..'9');

terminal WS: (' ' | '\t')+;

terminal EOL: NL;

terminal fragment NL: ('\r'? '\n');

terminal ANY:
	.;